================================================================================
TN5250J THREADING AUDIT - CRITICAL FINDINGS CHECKLIST
================================================================================

SEVERITY: CRITICAL - Production deployment blocked pending fixes

================================================================================
ISSUE #1: RACE CONDITION - Unsynchronized Socket Access
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/tnvt.java
Lines: 89-91 (declaration), 271 (write), 287-288 (write), 164+ (read by pthread)

Description:
  Socket sock, BufferedInputStream bin, and BufferedOutputStream bout are
  shared across 3 concurrent threads (main, me, pthread) with NO synchronization.

Code:
  Line 89:  private Socket sock;
  Line 90:  private BufferedInputStream bin;
  Line 91:  private BufferedOutputStream bout;

  Line 271: sock = sc.createSocket(s, port);           // main thread
  Line 287: bin = new BufferedInputStream(in, 8192);   // main thread
  Line 288: bout = new BufferedOutputStream(out);      // main thread

  DataStreamProducer.java (line 50, 144+):
    byte[] abyte0 = readIncoming();  // reads bin (pthread)

Consequence: Race conditions, null pointer exceptions, data corruption

Fix: Mark volatile or use synchronized block
  volatile Socket sock;
  volatile BufferedInputStream bin;
  volatile BufferedOutputStream bout;

Severity: CRITICAL
Status: UNFIXED

================================================================================
ISSUE #2: RACE CONDITION - Unsynchronized keepTrucking Flag
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/tnvt.java
Lines: 123 (declaration), 316 (write), 346 (write), 965 (read)

Description:
  boolean keepTrucking accessed from main thread and me thread without sync.
  Controls main run() loop - thread visibility issue.

Code:
  Line 123: private boolean keepTrucking = true;
  Line 316: keepTrucking = true;           // main thread (connect)
  Line 346: keepTrucking = false;          // main thread (disconnect)
  Line 965: while (keepTrucking) {         // me thread (run)

Consequence: Thread may not see state change, will not exit loop

Fix: Mark volatile
  volatile boolean keepTrucking = true;

Severity: CRITICAL
Status: UNFIXED

================================================================================
ISSUE #3: RACE CONDITION - Unsynchronized connected Flag
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/tnvt.java
Lines: 105 (declaration), 279 (write), 364 (write), 194 (read)

Description:
  boolean connected accessed from main and multiple worker threads.
  No synchronization, multiple visibility issues.

Code:
  Line 105: private boolean connected = false;
  Line 194: return connected;  // getter called from multiple threads
  Line 279: connected = true;  // main thread
  Line 364: connected = false; // main thread

Consequence: Inconsistent connection state, UI out of sync

Fix: Mark volatile
  volatile boolean connected = false;

Severity: CRITICAL
Status: UNFIXED

================================================================================
ISSUE #4: SWING EDT VIOLATION - Direct UI Updates from Non-EDT Thread
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/tnvt.java
Lines: 317-318 (thread creation), 958-1111 (run method)

Description:
  run() method executes in non-EDT thread 'me' and directly modifies Swing
  components without wrapping in SwingUtilities.invokeLater().

Code:
  Line 317: me = new Thread(this);
  Line 318: me.start();           // launches run() in non-EDT

  Line 958: public void run() {   // Executes in me thread (NOT EDT)
  Line 965:   while (keepTrucking) {
  Line 980:     screen52.setCursorActive(false);     // VIOLATION
  Line 1000:    screen52.updateDirty();              // VIOLATION
  Line 1052:    screen52.setCursorActive(true);      // VIOLATION
  Line 1058:    screen52.setCursorActive(true);      // VIOLATION
  Line 1066:    screen52.drawFields();               // VIOLATION
  Line 1086:    screen52.updateDirty();              // VIOLATION
  Line 1102:    screen52.setCursorActive(true);      // VIOLATION

Consequence: UI corruption, flickering, potential JVM crash

Fix: Wrap in SwingUtilities.invokeLater():
  SwingUtilities.invokeLater(new Runnable() {
      public void run() {
          screen52.setCursorActive(false);
      }
  });

Additional EDT Violations in parseIncoming():
  Line 1295: screen52.clearAll()
  Line 1313: screen52.goto_XY(y)
  Line 1397: screen52.drawFields()
  Line 1409: screen52.goto_XY(pos - 1)
  Line 1479: screen52.clearAll()
  Line 1505: screen52.clearAll()

Severity: CRITICAL
Status: UNFIXED
Count: 13 violations total

================================================================================
ISSUE #5: LISTENER RACE CONDITION - Unsynchronized fireStatusEvent()
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/tools/FTP5250Prot.java
Lines: 77 (declaration), 161 (add - synchronized), 174 (fire - NOT synchronized)

Description:
  Listener vector accessed with asymmetric synchronization. Add method is
  synchronized, but fire methods are not. Race condition on concurrent
  add/remove during iteration.

Code:
  Line 77:  private Vector<FTPStatusListener> listeners;

  Line 161: public synchronized void addFTPStatusListener(...) {
           // SYNCHRONIZED - safe
           listeners.addElement(listener);
           }

  Line 174: private void fireStatusEvent() {
           // NOT SYNCHRONIZED - UNSAFE
           if (listeners != null) {
               int size = listeners.size();
               for (int i = 0; i < size; i++) {
                   FTPStatusListener target = listeners.elementAt(i);
                   target.statusReceived(status);
               }
           }
           }

Race Scenario:
  Thread A: calls addFTPStatusListener()    (acquires lock)
  Thread B: calls fireStatusEvent()         (NO lock)
  Result: ConcurrentModificationException or IndexOutOfBoundsException

Fix: Make fire methods synchronized:
  private synchronized void fireStatusEvent() {
      if (listeners != null) {
          int size = listeners.size();
          for (int i = 0; i < size; i++) {
              FTPStatusListener target = listeners.elementAt(i);
              target.statusReceived(status);
          }
      }
  }

Affected Methods:
  Line 174: fireStatusEvent()
  Line 190: fireCommandEvent()
  Line 206: fireInfoEvent()

Severity: HIGH
Status: UNFIXED
Count: 3 methods

================================================================================
ISSUE #6: RESOURCE LEAK - Socket Not Closed on Exception
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/tools/FTP5250Prot.java
Lines: 513-629 (loadFFD method)

Description:
  Socket and BufferedReader created but never closed if exception occurs.
  No finally block, early returns without cleanup.

Code:
  Line 513: private boolean loadFFD(boolean useInternal) {
  Line 515: Socket socket = null;
  Line 516: BufferedReader dis = null;
  Line 522: socket = createPassiveSocket("RETR " + remoteFile);
  Line 528: dis = new BufferedReader(
              new InputStreamReader(socket.getInputStream()));
  Line 537: while ((data = dis.readLine()) != null) {
              // If readLine() throws IOException here...
              // Socket and dis are never closed!
           }
  Line 623: } catch (Exception e) {
  Line 624:   return false;  // LEAK - cleanup never happens
  Line 625: }
  // NO FINALLY BLOCK

Leak Scenario:
  1. socket = createPassiveSocket() succeeds
  2. dis = new BufferedReader() succeeds
  3. dis.readLine() throws IOException
  4. catch block executes
  5. return false without closing socket or dis
  6. File descriptor leaked

Impact:
  After ~100-200 failed transfers, JVM exhausts file descriptors.
  No new network connections possible.

Fix: Add try-finally:
  try {
      socket = createPassiveSocket(...);
      if (socket == null) return false;

      dis = new BufferedReader(...);
      while ((data = dis.readLine()) != null) {
          // process
      }
  } catch (Exception e) {
      return false;
  } finally {
      if (dis != null) try { dis.close(); } catch (Exception e) {}
      if (socket != null) try { socket.close(); } catch (Exception e) {}
  }

Or use try-with-resources (Java 7+):
  try (Socket socket = createPassiveSocket(...);
       BufferedReader dis = new BufferedReader(...)) {
      while ((data = dis.readLine()) != null) {
          // process
      }
  } catch (Exception e) {
      return false;
  }

Severity: CRITICAL
Status: UNFIXED

================================================================================
ISSUE #7: RESOURCE LEAK - Early Return Without Stream Closure
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/tnvt.java
Lines: 335-386 (disconnect method)

Description:
  Early return if !connected leaves bin and bout open.
  No guarantee streams close if exception occurs in close block.

Code:
  Line 335: public final boolean disconnect() {
  Line 338:   if (!connected) {
  Line 339:     screen52.getOIA().setInputInhibited(...);
  Line 340:     return false;  // BUG: bin/bout not closed
  Line 341:   }

  Line 356:   try {
  Line 357:     if (sock != null) {
  Line 358:       log.info("Closing socket");
  Line 359:       sock.close();
  Line 360:     }
  Line 361:     if (bin != null)
  Line 362:       bin.close();     // May throw
  Line 363:     if (bout != null)
  Line 364:       bout.close();    // May throw
  Line 377:   } catch (Exception exception) {
  Line 378:     log.warn(exception.getMessage());
  Line 379:     connected = false;
  Line 381:     return false;    // PARTIAL CLOSURE
  Line 382:   }

Issues:
  1. Line 338-341: If !connected, streams never close
  2. Line 377-381: Exception in close() leaves state inconsistent

Severity: CRITICAL
Status: UNFIXED

================================================================================
ISSUE #8: RESOURCE LEAK - ServerSocket Not Closed on Exception
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/tools/FTP5250Prot.java
Lines: 419-456 (createPassiveSocket method)

Description:
  ServerSocket created but not closed in SocketException catch block.
  Only closed in InterruptedIOException path.

Code:
  Line 424: ss = new ServerSocket(0);

  Line 449: } catch (InterruptedIOException ioexception) {
  Line 450:   try {
  Line 451:     ss.close();  // Closed here
  Line 452:   } catch (Exception ioexception1) {
  Line 453:   }
  Line 454: } catch (SocketException ioexception) {
  // NO ss.close() in this path!
  Line 455:   socket = null;
  Line 456: }

Leak Scenario:
  1. ss = new ServerSocket(0) succeeds
  2. ss.accept() throws SocketException
  3. SocketException catch block executes
  4. ServerSocket never closed
  5. Server socket port remains bound

Severity: HIGH
Status: UNFIXED

================================================================================
ISSUE #9: EDT VIOLATION - fireSessionChanged() from Non-EDT Thread
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/tnvt.java
Lines: 1010-1013

Description:
  fireSessionChanged() called from me thread (non-EDT). Listeners may
  perform UI updates, causing cross-thread Swing modifications.

Code:
  Line 1010: if (!firstScreen) {
  Line 1011:   firstScreen = true;
  Line 1012:   controller.fireSessionChanged(
               TN5250jConstants.STATE_CONNECTED);  // CALLED FROM me THREAD
  Line 1013: }

Context: Inside run() method (line 958) which executes in non-EDT thread

Consequence: State listeners trigger UI updates from non-EDT thread

Fix: Wrap in SwingUtilities.invokeLater():
  if (!firstScreen) {
      firstScreen = true;
      SwingUtilities.invokeLater(new Runnable() {
          public void run() {
              controller.fireSessionChanged(
                  TN5250jConstants.STATE_CONNECTED);
          }
      });
  }

Severity: HIGH
Status: UNFIXED

================================================================================
ISSUE #10: DEADLOCK POTENTIAL - invokeAndWait() from EDT
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/tnvt.java
Lines: 254-259, 305-310

Description:
  SwingUtilities.invokeAndWait() used in connect() method. If connect()
  is called from EDT thread, it will deadlock waiting for itself.

Code:
  Line 254: SwingUtilities.invokeAndWait(new Runnable() {
  Line 255:   public void run() {
  Line 256:     screen52.getOIA().setInputInhibited(...);
  Line 257:   }
  Line 258: });

Deadlock Scenario:
  1. EDT thread calls connect()
  2. connect() calls SwingUtilities.invokeAndWait()
  3. EDT thread blocks, waiting for Runnable to execute
  4. EDT thread waits for itself to execute Runnable
  5. DEADLOCK - EDT thread never executes

Fix: Use invokeLater() instead of invokeAndWait():
  SwingUtilities.invokeLater(new Runnable() {
      public void run() {
          screen52.getOIA().setInputInhibited(...);
      }
  });

Or check current thread:
  if (SwingUtilities.isEventDispatchThread()) {
      screen52.getOIA().setInputInhibited(...);
  } else {
      SwingUtilities.invokeAndWait(new Runnable() { ... });
  }

Severity: MEDIUM
Status: UNFIXED

================================================================================
ISSUE #11: BLOCKING WITHOUT TIMEOUT - dsq.take()
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/tnvt.java
Lines: 965-973

Description:
  BlockingQueue.take() blocks indefinitely. No timeout mechanism. Thread
  cannot be interrupted cleanly on disconnect.

Code:
  Line 965: while (keepTrucking) {
  Line 968:   bk.initialize((byte[]) dsq.take());  // BLOCKS FOREVER
  Line 969:   // ...
  Line 970: } catch (InterruptedException ie) {
  Line 971:   log.warn("   vt thread interrupted and stopping ");
  Line 972:   keepTrucking = false;
  Line 973:   continue;

Issue: If no data in queue, take() blocks. Thread.interrupt() may not
       wake it immediately. Thread.yield() at line 1108 does nothing.

Consequence: Thread may hang on disconnect, preventing clean shutdown

Fix: Use poll() with timeout:
  try {
      byte[] data = dsq.poll(5, TimeUnit.SECONDS);
      if (data != null) {
          bk.initialize(data);
      }
  } catch (InterruptedException ie) {
      log.warn("   vt thread interrupted and stopping ");
      keepTrucking = false;
  }

Severity: CRITICAL
Status: UNFIXED

================================================================================
ISSUE #12: BLOCKING I/O WITHOUT TIMEOUT
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/DataStreamProducer.java
Lines: 50, 154

Description:
  BufferedInputStream.read() blocks indefinitely with no timeout.
  Thread cannot exit cleanly on disconnect.

Code:
  Line 50:  byte[] abyte0 = readIncoming();  // BLOCKING

  Line 144: public final byte[] readIncoming() throws IOException {
  Line 154:   int i = bin.read();  // BLOCKS FOREVER if no data

Consequence: Thread may hang if network connection stalls

Fix: Set socket timeout in tnvt.connect():
  Line 281-283:
    sock.setKeepAlive(true);
    sock.setTcpNoDelay(true);
    sock.setSoTimeout(30000);  // 30 second timeout

Severity: HIGH
Status: UNFIXED

================================================================================
ISSUE #13: LISTENER COLLECTION RACE - Screen5250
================================================================================
File: /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/Screen5250.java
Lines: 95-96

Description:
  screenListeners Vector accessed without synchronization. Same pattern
  as FTP5250Prot listener issue.

Code:
  Line 95: private Vector<ScreenListener> screenListeners = null;

  Accessed in:
    - addScreenListener()
    - removeScreenListener()
    - fireScreenChanged()
    - fireCursorChanged()

  All without synchronization.

Consequence: ConcurrentModificationException during listener notification

Fix: Synchronize listener access:
  private synchronized void fireScreenChanged(...) {
      if (screenListeners != null) {
          // iterate listeners
      }
  }

Severity: MEDIUM
Status: UNFIXED

================================================================================
SUMMARY
================================================================================

Total Issues Found: 13
Critical Issues: 6
High Issues: 4
Medium Issues: 3

Files Affected:
  1. /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/tnvt.java
  2. /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/tools/FTP5250Prot.java
  3. /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/DataStreamProducer.java
  4. /Users/vorthruna/Projects/tn5250j/src/org/tn5250j/framework/tn5250/Screen5250.java

Recommendation: Fix all CRITICAL and HIGH issues before production deployment.

