================================================================================
HTI5250J SCALABILITY - QUICK REFERENCE CARD
================================================================================

CURRENT STATE: ~100-150 concurrent sessions max
TARGET STATE:  1000+ concurrent sessions for Robot Framework

================================================================================
TIER 1 BOTTLENECKS (Critical - P0)
================================================================================

[1] GUI COUPLING IN HEADLESS MODE
    Location: GuiGraphicBuffer.java:54, 206-211
    Cost:     6-8 MB per session × 1000 = 6-8 GB wasted heap
    Fix:      Create HeadlessRenderer (no-op) vs SwingRenderer factory
    Effort:   1-2 days
    Gain:     Heap per 1000 sessions: 4-8 GB → 1-2 GB

[2] LOCK CONTENTION ON Screen5250
    Location: Screen5250.java (12 synchronized methods)
    Cost:     Lock hold time 10-15ms × 1000 threads = serial throughput
    Fix:      Replace synchronized → ReadWriteLock
    Effort:   2-3 days
    Gain:     Throughput: 67 ops/sec → 500-1000 ops/sec

COMBINED P0 IMPACT: Enables baseline 1000 session capability

================================================================================
TIER 2 OPTIMIZATIONS (Important - P1)
================================================================================

[3] NO CONNECTION POOLING
    Location: SessionManager.java:86, BatchExecutor.java:116
    Cost:     100-400ms per connection × 1000 = 100-400s startup
    Fix:      Implement SessionPool with 50-100 connection reuse
    Effort:   3-5 days
    Gain:     Startup time: 100-400s → 10-50s

[4] LISTENER VECTOR COPIES
    Location: Screen5250.java:3285, 3321, 3335
    Cost:     100 MB/sec GC pressure at high concurrency
    Fix:      Replace Vector → CopyOnWriteArrayList
    Effort:   1 day
    Gain:     GC pause reduction: 500ms-2s → 100-200ms

[5] SCREENPLANES MEMORY BLOAT
    Location: ScreenPlanes.java:31-46, 97-108
    Cost:     9 char arrays × 80-120 KB per session
    Fix:      Packed representation or lazy planes
    Effort:   3-5 days
    Gain:     Per-session: 80 KB → 40 KB

================================================================================
IMPLEMENTATION CHECKLIST
================================================================================

PHASE 15A (1-2 days) - Headless GUI Decoupling
[ ] Create ScreenRenderer interface
[ ] Implement HeadlessRenderer (no-op)
[ ] Implement SwingRenderer (wrap GuiGraphicBuffer)
[ ] Add factory in Session5250
[ ] Verify: Single headless session <500 KB heap

PHASE 15B (2-3 days) - ReadWriteLock Implementation
[ ] Add ReadWriteLock field to Screen5250
[ ] Refactor read methods → readLock()
[ ] Refactor write methods → writeLock()
[ ] Separate listener notification from lock
[ ] Verify: 100+ concurrent reads at <10ms latency

PHASE 15C (3-5 days) - Connection Pooling [OPTIONAL]
[ ] Create SessionPool class
[ ] Modify BatchExecutor for pool acquire/release
[ ] Add connection validation logic
[ ] Implement timeout and backoff
[ ] Verify: 1000 workflows startup in <50s

================================================================================
VERIFICATION TESTS (Post-Implementation)
================================================================================

Test: Headless Memory Usage
  Config: 1000 workflows, headless mode
  Assert: Total heap < 1 GB
  Current: ~4 GB (fails)
  After P0: ~1-2 GB (passes)

Test: Lock Contention
  Config: 50 concurrent readers + 50 concurrent writers
  Assert: Average operation <10ms
  Current: ~100ms (fails)
  After P0: ~5-10ms (passes)

Test: Startup Time
  Config: 1000 workflows sequential creation
  Assert: Total startup < 50s
  Current: 100-400s (fails)
  After P1: 10-50s (passes)

================================================================================
PERFORMANCE PROJECTIONS
================================================================================

Metric                          Before P0      After P0       After P0+P1
────────────────────────────────────────────────────────────────────────
Max concurrent sessions         ~100-150       ~300-500       ~1000+
Heap per 1000 sessions          4-8 GB         1-2 GB         1-2 GB
Lock wait (@ 1000 concurrent)   800ms-2s       50-100ms       50-100ms
Connection startup (1000)       100-400s       100-400s       10-50s
Per-session memory              2-5 MB         250 KB         250 KB

================================================================================
QUICK WINS (Can implement immediately)
================================================================================

1. REMOVE BufferedImage from headless path
   - In GuiGraphicBuffer constructor, check headlessMode
   - Skip "bi = new BufferedImage(...)" if headless
   - Impact: 6-8 MB × 1000 = 6-8 GB saved
   - Time: 30 minutes

2. REPLACE Vector with CopyOnWriteArrayList
   - File: Screen5250.java
   - Change: Vector<ScreenListener> → CopyOnWriteArrayList<ScreenListener>
   - Remove: Defensive copy (new Vector(screenListeners))
   - Impact: 100 MB/sec GC reduction
   - Time: 1 hour

3. ADD FEATURE FLAG FOR HEADLESS MODE
   - System property: -Dheadless.mode=true
   - Disable GuiGraphicBuffer instantiation entirely
   - Disable all rendering paths
   - Impact: Allows headless validation immediately
   - Time: 2-3 hours

================================================================================
RISK MITIGATION
================================================================================

P0 Changes (GUI Removal):
  - Use feature flag for backward compatibility
  - Existing tests remain unchanged (GUI mode still available)
  - New headless tests verify new path
  - Rollback: One line change in Session5250

P1 Changes (Connection Pooling):
  - Implement as wrapper around Session5250
  - Existing code path unaffected (can disable pooling)
  - Add per-pool metrics for monitoring
  - Rollback: Switch from pool.acquire() back to direct create()

================================================================================
NEXT STEPS
================================================================================

1. Approve Phase 15A implementation plan
2. Create feature branch: feature/phase-15a-headless-decoupling
3. Implement in order:
   - HeadlessRenderer interface
   - Update Session5250 constructor
   - Update BatchExecutor for headless mode
   - Add tests for memory usage
4. Measure: Verify heap usage with 100 concurrent headless sessions
5. Decision: Proceed to Phase 15B if target met

Target Timeline: Phase 15A (3-5 days) + Phase 15B (2-3 days) = 1 week

================================================================================
CONTACTS & ESCALATION
================================================================================

Lead Architect: Eric Mumford (@heymumford)
Performance Analysis: Claude Code (Performance Oracle)
Questions: See PERFORMANCE_ANALYSIS.md for detailed breakdown

